// Code generated by mockery v1.0.0. DO NOT EDIT.
package mocks

import k8s "github.com/liquidweb/kube-cert-manager/internal/k8s"
import mock "github.com/stretchr/testify/mock"

import v1 "k8s.io/client-go/pkg/api/v1"

// KubeAdapter is an autogenerated mock type for the KubeAdapter type
type KubeAdapter struct {
	mock.Mock
}

// CreateEvent provides a mock function with given fields: _a0
func (_m *KubeAdapter) CreateEvent(_a0 v1.Event) {
	_m.Called(_a0)
}

// DeleteCertificate provides a mock function with given fields: _a0, _a1
func (_m *KubeAdapter) DeleteCertificate(_a0 k8s.Certificate, _a1 string) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(k8s.Certificate, string) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSecret provides a mock function with given fields: _a0, _a1
func (_m *KubeAdapter) DeleteSecret(_a0 string, _a1 string) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCertificates provides a mock function with given fields: _a0
func (_m *KubeAdapter) GetCertificates(_a0 string) ([]k8s.Certificate, error) {
	ret := _m.Called(_a0)

	var r0 []k8s.Certificate
	if rf, ok := ret.Get(0).(func(string) []k8s.Certificate); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]k8s.Certificate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecret provides a mock function with given fields: _a0, _a1
func (_m *KubeAdapter) GetSecret(_a0 string, _a1 string) (*v1.Secret, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *v1.Secret
	if rf, ok := ret.Get(0).(func(string, string) *v1.Secret); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecrets provides a mock function with given fields: _a0
func (_m *KubeAdapter) GetSecrets(_a0 string) ([]v1.Secret, error) {
	ret := _m.Called(_a0)

	var r0 []v1.Secret
	if rf, ok := ret.Get(0).(func(string) []v1.Secret); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1.Secret)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MonitorCertificateEvents provides a mock function with given fields: _a0, _a1
func (_m *KubeAdapter) MonitorCertificateEvents(_a0 string, _a1 <-chan struct{}) <-chan k8s.CertificateEvent {
	ret := _m.Called(_a0, _a1)

	var r0 <-chan k8s.CertificateEvent
	if rf, ok := ret.Get(0).(func(string, <-chan struct{}) <-chan k8s.CertificateEvent); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan k8s.CertificateEvent)
		}
	}

	return r0
}

// SaveSecret provides a mock function with given fields: _a0, _a1, _a2
func (_m *KubeAdapter) SaveSecret(_a0 string, _a1 *v1.Secret, _a2 bool) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *v1.Secret, bool) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCertSpec provides a mock function with given fields: _a0, _a1, _a2
func (_m *KubeAdapter) UpdateCertSpec(_a0 string, _a1 string, _a2 k8s.CertificateSpec) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, k8s.CertificateSpec) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateCertStatus provides a mock function with given fields: _a0, _a1, _a2
func (_m *KubeAdapter) UpdateCertStatus(_a0 string, _a1 string, _a2 k8s.CertificateStatus) {
	_m.Called(_a0, _a1, _a2)
}
